import{a8 as C,j as _,a9 as b,r as u,aa as O,ab as B,ac as H,a as m,ad as M,ae as N,af as R,N as E,ag as j}from"./BD2EHp4x.js";const z=s=>s==="defer"||s===!1;function F(...s){var h;const n=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(n);let[e,d,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof d!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=_(),v=d,p=()=>null,g=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??p,a.getCachedData=a.getCachedData??g,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??b.deep,a.dedupe=a.dedupe??"cancel";const f=()=>a.getCachedData(e,t)!=null;if(!t._asyncData[e]||!a.immediate){(h=t.payload._errors)[e]??(h[e]=null);const o=a.deep?u:O;t._asyncData[e]={data:o(a.getCachedData(e,t)??a.default()),pending:u(!f()),error:B(t.payload._errors,e),status:u("idle")}}const r={...t._asyncData[e]};r.refresh=r.execute=(o={})=>{if(t._asyncDataPromises[e]){if(z(o.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((o._initial||t.isHydrating&&o._initial!==!1)&&f())return Promise.resolve(a.getCachedData(e,t));r.pending.value=!0,r.status.value="pending";const l=new Promise((i,c)=>{try{i(v(t))}catch(w){c(w)}}).then(async i=>{if(l.cancelled)return t._asyncDataPromises[e];let c=i;a.transform&&(c=await a.transform(i)),a.pick&&(c=K(c,a.pick)),t.payload.data[e]=c,r.data.value=c,r.error.value=null,r.status.value="success"}).catch(i=>{if(l.cancelled)return t._asyncDataPromises[e];r.error.value=R(i),r.data.value=E(a.default()),r.status.value="error"}).finally(()=>{l.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=l,t._asyncDataPromises[e]},r.clear=()=>x(t,e);const y=()=>r.refresh({_initial:!0}),P=a.server!==!1&&t.payload.serverRendered;{const o=j();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const i=o._nuxtOnBeforeMountCbs;o&&(H(()=>{i.forEach(c=>{c()}),i.splice(0,i.length)}),m(()=>i.splice(0,i.length)))}P&&t.isHydrating&&(r.error.value||f())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?o._nuxtOnBeforeMountCbs.push(y):a.immediate&&y(),a.watch&&M(a.watch,()=>r.refresh());const l=t.hook("app:data:refresh",async i=>{(!i||i.includes(e))&&await r.refresh()});o&&m(l)}const D=Promise.resolve(t._asyncDataPromises[e]).then(()=>r);return Object.assign(D,r),D}async function I(s){await new Promise(e=>C(e));const n=s?N(s):void 0;await _().hooks.callHookParallel("app:data:refresh",n)}function x(s,n){n in s.payload.data&&(s.payload.data[n]=void 0),n in s.payload._errors&&(s.payload._errors[n]=null),s._asyncData[n]&&(s._asyncData[n].data.value=void 0,s._asyncData[n].error.value=null,s._asyncData[n].pending.value=!1,s._asyncData[n].status.value="idle"),n in s._asyncDataPromises&&(s._asyncDataPromises[n].cancelled=!0,s._asyncDataPromises[n]=void 0)}function K(s,n){const e={};for(const d of n)e[d]=s[d];return e}export{I as r,F as u};
